# You may distribute this module under the same terms as perl itself
#
# POD documentation - main docs before the code

=pod 

=head1 NAME

Bio::EnsEMBL::Analysis::RunnableDB::Spliced_elsewhere;

=head1 SYNOPSIS

my $runnabledb = Bio::EnsEMBL::Analysis::RunnableDB::Spliced_elsewhere->new
  (			
   -db => $dbadaptor,
   -input_id => flag ids,	
   -analysis => $analysis
  );

$runnabledb->fetch_input();
$runnabledb->run();
$runnabledb->write_output();

=head1 DESCRIPTION

Spliced elsewhere checks single exon transcripts and looks for copies 
elsewhere in the genome that contain introns ie: processed pseudogenes.
The module runs on chunk files generated by scripts in: 
ensembl-personal/sw4/Scripts/Pseudogenes
which partition the database into single and multiexon genes.The single exon 
genes are written to flat files, the multiexon genes are written into the target
databse and also formatted as a blast db.

The module calls a gene spliced elsewhere if it is > 80% identical to another EnsEMBL
transcript with > 80 % coverage and the target gene has a genomic span > 3x the 
span of the query. These numbers are configurable through:
Bio::EnsEMBL::Analysis::Config::Pseudogene

The databses used by the module are configured through:
Bio::EnsEMBL::Analysis::Config::Databases;

Runs as a part of the larger pseudogene analysis. Uses flagged single exon genes
identified by Bio::EnsEMBL::Analysis::RunnableDB::Pseudogene_DB.pm

=head1 CONTACT

Post questions to the Ensembl development list: ensembl-dev@ebi.ac.uk

=cut


package Bio::EnsEMBL::Analysis::RunnableDB::Spliced_elsewhere;


use strict;
use Bio::EnsEMBL::Analysis::RunnableDB;
use Bio::EnsEMBL::Analysis::Config::Pseudogene;
use Bio::EnsEMBL::Analysis::Config::Databases;
use Bio::EnsEMBL::Analysis::Runnable::Spliced_elsewhere;
use Bio::EnsEMBL::Analysis::RunnableDB::Pseudogene_DB;
use Bio::EnsEMBL::Pipeline::DBSQL::FlagAdaptor;
use vars qw(@ISA);

@ISA = qw(Bio::EnsEMBL::Analysis::RunnableDB::Pseudogene_DB);




=head2 fetch_input

Title   :   fetch_input
  Usage   :   $self->fetch_input
 Function:   Fetches input data for Spliced_elsewhere.pm from the database and flat files
  Returns :   none
  Args    :   none

=cut

sub fetch_input{
  my ($self)=@_;
  my ($start, $end);
  my @genes;
  my $count=0;
  my %parameters;
  if ($self->parameters_hash) {
    %parameters = %{$self->parameters_hash};
  }
  my $runname = "Bio::EnsEMBL::Analysis::Runnable::Spliced_elsewhere";

  my $dna_db = new Bio::EnsEMBL::DBSQL::DBAdaptor
    (
     '-host'   => $GB_DBHOST,
     '-user'   => $GB_DBUSER,
     '-dbname' => $GB_DBNAME,
     '-pass'   => $GB_DBPASS,
     '-port'   => $GB_DBPORT,
    );
  #store repeat db internally
  $self->rep_db($dna_db);

  #genes come from final genebuild database
  my $genes_db = new Bio::EnsEMBL::DBSQL::DBAdaptor
    (
     '-host'   => $GB_FINALDBHOST,
     '-user'   => $GB_FINALDBUSER,
     '-dbname' => $GB_FINALDBNAME,
     '-pass'   => $GB_FINALDBPASS,
     '-port'   => $GB_FINALDBPORT,
     '-dnadb'  => $dna_db,
    );
  $self->gene_db($genes_db);
  my $ga = $genes_db->get_GeneAdaptor;
  my $fa = Bio::EnsEMBL::Pipeline::DBSQL::FlagAdaptor->new($self->db);
  my $ids = $fa->fetch_by_analysis($self->analysis);
  $self->throw("No flags found for analysis $SPLICED_ELSEWHERE_LOGIC_NAME\n")  unless (scalar(@{$ids}>0));
  if ($self->input_id =~ /(\d+):(\d+)/) {
    $start = $1;
    $end = $2;
  } else {
    $self->throw("Input id not recognised\n");
  }
  # get ids
  foreach my $flag (@{$ids}) {
    if ($flag->dbID >= $start && $flag->dbID <= $end) {
      $count++;
      my $gene = $ga->fetch_by_dbID($flag->ensembl_id);
      push @genes, $self->lazy_load($gene);
    }
  }
  print "$count genes retrieved\n";
  my $runnable = $runname->new (
				'-genes' => \@genes,
				'-analysis' => $self->analysis,
			       );
  $self->runnable($runnable);
  return 1;
}

=head2 run

Title   :   run
  Usage   :   $self->run
 Function:   Overrides run method in parent class
  Returns :   none
  Args    :   none

=cut

sub run {
  my($self) = @_;
  foreach my $runnable (@{$self->runnable}) {
    $self->throw("Runnable module not set") unless ($runnable);
    $runnable->run;
    $self->parse_results($runnable->output);
    $self->output($self->real_genes);
    # If you want to store retrotransposed genes for psilc
    return 1 unless ($self->retro_genes);
    if ($RETROTRANSPOSED ) {
      # Store gene dbIDS for PSILC 
      my @id_list;
      foreach my $gene (@{$self->retro_genes}) {
	push @id_list, $gene->dbID;
      }
      $self->store_ids(\@id_list,"psilc");
    } else {
      # store retrotransposed genes as pseudo or real depending on config
      foreach my $gene (@{$self->retro_genes}) {
	if ($RETRO_TYPE eq 'pseudogene') {
	  $self->pseudo_genes($gene);
	} else {	
	  $gene->type($RETRO_TYPE);
	  $self->output($gene);
	}
      }
    }
    $self->output($self->pseudo_genes);
  }
  return 1;
}

# Blast parsing done in runnable db as it needs acess to database to determine
# gene span

=head2 parse_results

Title   :   parse_results
  Usage   :   $self->parse_results
 Function:   Parses blast results to find spliced copies.
  Tests percent ID, coverage and span.
  Span is calculated as the distance between two genomic cordinates 
  corresponding to the HSP subject start and end positions
  Returns :   none
  Args    :   none

=cut

sub  parse_results{
  my ($self,$results)=@_;
  my $ta = $self->gene_db->get_TranscriptAdaptor;
  my $ga = $self->gene_db->get_GeneAdaptor;
 RESULT:foreach my $result_hash_ref (@{$results}) {    
    my %result_hash = %{$result_hash_ref};
    my %trans_type =();  
  TRANS: foreach my $id (keys %result_hash){  
      my $retro_trans = $ta->fetch_by_dbID($id);
      my $retro_span = $retro_trans->cdna_coding_end- $retro_trans->cdna_coding_start;
      my @dafs =  @{$result_hash{$id}};      
      @dafs = sort {$b->p_value <=> $a->p_value} @dafs;
    DAF: foreach my $daf (@dafs) {
	# is the percent id above threshold?
	next DAF unless ($daf->percent_id > $PS_PERCENT_ID_CUTOFF);
	my $coverage = int($daf->length/$retro_trans->translate->length*100);
	# is the coverage above the threshold?
	next DAF unless ($coverage > $PS_PERCENT_ID_CUTOFF);
	my $real_trans;
	# Warn if transcript cannot be found
	eval{
	  $real_trans =   $ta->fetch_by_translation_id($daf->hseqname);
	};
	if ($@) {
	  $self->warn("Unable to find translation $daf->hseqname \n$@\n");
	  next;
	}
	
	##################################################################
	# real span is the genomic span of the subject HSP
	# hstart+3 and $daf->hend-3 move inwards at both ends of the HSP by
	# 3 residues, this is so that if 1 residue is sitting on a new exon
	# it wont include that in the span, needs to overlap by 3 residues 
	# before it gets included
	
	my $real_span;
	my @genomic_coords = $real_trans->pep2genomic($daf->hstart+3,$daf->hend-3);
	@genomic_coords = sort {$a->start <=> $b->start} @genomic_coords;
	$real_span = $genomic_coords[$#genomic_coords]->end - $genomic_coords[0]->start;
	
	# Is the span higher than the allowed ratio?
	if ($real_span / $retro_span > $PS_SPAN_RATIO ) {
	  print STDERR "transcript id ". $retro_trans->dbID." matches translation id " . $daf->hseqname . " at "
	    . $daf->percent_id . " %ID and $coverage % coverage with pseudogene span of $retro_span vs real gene span of $real_span\n";
	  print STDERR ">".$retro_trans->dbID;
	  print STDERR "\n".$retro_trans->translate->seq."\n";
	  # Gene is pseudo, store it internally
	  push @{$trans_type{'pseudo'}},$retro_trans;
	  next TRANS;
	}
      }
      # transcript is real
      push @{$trans_type{'real'}},$retro_trans; 	
    }
    unless ($trans_type{'real'}) {
      # if all transcripts are pseudo get label the gene as a pseudogene
      my $gene = $ga->fetch_by_transcript_id($trans_type{'pseudo'}[0]->dbID);
      $self->retro_genes($gene);
      next RESULT;
    }
    # gene has at least on ereal transcript so it is real
    $self->real_genes($ga->fetch_by_transcript_id($trans_type{'real'}[0]->dbID));
  }
  return 1; 
}


######################################
# CONTAINERS


=head2 retro_genes

Arg [1]    : Bio::EnsEMBL::Gene
 Description: get/set for retrogenes 
  Returntype : Bio::EnsEMBL::Gene
  Exceptions : none
  Caller     : general

=cut

sub retro_genes {
  my ($self, $retro_gene) = @_;
  if ($retro_gene) {
    unless ($retro_gene->isa("Bio::EnsEMBL::Gene")){
      $self->throw("retro gene is not a Bio::EnsEMBL::Gene, it is a $retro_gene");
    }
    push @{$self->{'_retro_gene'}},$self->lazy_load($retro_gene);
  }
  return $self->{'_retro_gene'};
}





1;
