#
# package Bio::EnsEMBL::Pipeline::Config::ExonerateTranscript
# 
# Cared for by EnsEMBL (ensembl-dev@ebi.ac.uk)
#
# Copyright GRL & EBI
#
# You may distribute this module under the same terms as perl itself

# POD documentation - main docs before the code

=head1 NAME

Bio::EnsEMBL::Pipeline::Config::Affy::Exonerate2Affy

=head1 SYNOPSIS

    use Bio::EnsEMBL::Pipeline::Config::Exonerate2Genes;

=head1 DESCRIPTION

This contains the configuration for the  alignment of clone
sequences (dna) against a genome (dna)
using exonerate. So this config looks very similar to that
of any other exonerate-driving config.

The layout of the configuration is a set of hashes,
each one keyed by logic name. There is also a DEFAULT hash,
which is used as the default for all logic names 

=head1 CONTACT

=cut


package Bio::EnsEMBL::Analysis::Config::ExonerateCloneEnds;

use strict;
use vars qw( %Config );

%Config = (
  CLONE_CONFIG => {
    DEFAULT => {
  
      GENOMICSEQS  =>   undef, #allowed to be a dir.
      QUERYTYPE    => 'dna',

      # must be a single file containing all clone fasta sequences

      QUERYSEQS    => undef,

      # must supply one, since the queryseqs MUST be a single file 
      IIDREGEXP    => undef,
      DNADB => {
        -dbname => 'bos_taurus_core_36_2',#'homo_sapiens_core_36_35i',#'bos_taurus_core_36_2',
        -host   => 'ecs2',
        -port   => '3364',
        -user   => 'ensro',
        -pass   => '',
        },
      OPTIONS   => '--model affine:local --refine full --gapopen -8 --gapextend -2 --bestn 1  --dnawordlen 12 --forwardcoordinates FALSE --softmasktarget TRUE --score 100',
    },
     EXONERATE_CLONE_ENDS => {

      # path to softmasked, dusted sequence on the farm 
      # 
      
      GENOMICSEQS  => '/data/blastdb/Ensembl/Cow/v2/genome/Bos_taurus.mask.dust.soft.fa',  
      #GENOMICSEQS  => '/data/blastdb/Ensembl/Human/NCBI35/softmasked_dusted', #allowed to be a dir.
      QUERYTYPE    => 'dna',

      # must be a single file containing all clone fasta sequences

      QUERYSEQS    => '/ecs2/scratch2/jb16/sheep/sheep_clones.fa',

      # must supply one, since the queryseqs MUST be a single file 
      IIDREGEXP    => '(\d+):(\d+)',
      DNADB => {
        -dbname => 'bos_taurus_core_36_2',#'homo_sapiens_core_36_35i',#'bos_taurus_core_36_2',
        -host   => 'ecs2',
        -port   => '3364',
        -user   => 'ensro',
        -pass   => '',
        },
      OUTDB => {
        -dbname => 'jb16_sheep_cow_clones',#'jb16_sheep_human_clones',  
        -host   => 'ia64g',
        -port   => '3306',
        -user   => 'ensadmin',
        -pass   => 'ensembl',
        },
      OPTIONS   => '--model affine:local --gapopen -8 --gapextend -2 --bestn 10  --dnawordlen 12 --forwardcoordinates FALSE --softmasktarget TRUE --score 100',
    },
    REFINE_CLONE_ENDS => {
  
      #GENOMICSEQS  =>   '/data/blastdb/Ensembl/Human/NCBI35/softmasked_dusted', #allowed to be a dir.
      GENOMICSEQS  => '/data/blastdb/Ensembl/Cow/v2/genome/Bos_taurus.mask.dust.soft.fa',
      QUERYTYPE    => 'dna',

      # must be a single file containing all clone fasta sequences

      QUERYSEQS    => '/ecs2/scratch2/jb16/sheep/sheep_clones.fa',

      # must supply one, since the queryseqs MUST be a single file 
      IIDREGEXP    => '(\w+):(\w+):(\w+):(\w+):(\w+):(\w+):(\w+)',
      DNADB => {
        -dbname => 'bos_taurus_core_36_2',#'homo_sapiens_core_36_35i',#'bos_taurus_core_36_2',
        -host   => 'ecs2',
        -port   => '3364',
        -user   => 'ensro',
        -pass   => '',
        },
      OUTDB => {
        -dbname => 'jb16_sheep_cow_clones',#'jb16_sheep_human_clones',  
        -host   => 'ia64g',
        -port   => '3306',
        -user   => 'ensadmin',
        -pass   => 'ensembl',
        },
      OPTIONS   => '--model affine:local --refine full --gapopen -8 --gapextend -2 --bestn 1  --dnawordlen 12 --forwardcoordinates FALSE --softmasktarget TRUE --score 100',
    },
  }
);

sub import {
  my ($callpack) = caller(0); # Name of the calling package
  my $pack = shift; # Need to move package off @_

  # Get list of variables supplied, or else everything
  my @vars = @_ ? @_ : keys( %Config );
  return unless @vars;
  
  # Predeclare global variables in calling package
  eval "package $callpack; use vars qw("
    . join(' ', map { '$'.$_ } @vars) . ")";
    die $@ if $@;


    foreach (@vars) {
	if ( defined $Config{$_} ) {
            no strict 'refs';
	    # Exporter does a similar job to the following
	    # statement, but for function names, not
	    # scalar variables:
	    *{"${callpack}::$_"} = \$Config{ $_ };
	} else {
	    die "Error: Config: $_ not known\n";
	}
    }
}

1;
