#
# package Bio::EnsEMBL::Analysis::Config::GeneBuild::LayerAnnotation
# 
# Cared for by EnsEMBL (ensembl-dev@ebi.ac.uk)
#
# Copyright GRL & EBI
#
# You may distribute this module under the same terms as perl itself

# POD documentation - main docs before the code

=head1 NAME

Bio::EnsEMBL::Analysis::Config:GeneBuild::LayerAnnotation

=head1 SYNOPSIS

    use Bio::EnsEMBL::Analysis::Config::Genebuild::LayerAnnotation

=cut


package Bio::EnsEMBL::Analysis::Config::GeneBuild::LayerAnnotation;

use strict;
use vars qw( %Config );

# Hash containing config info
%Config = (
           LAYERANNOTATION_CONFIG_BY_LOGIC => {
             DEFAULT => {

               TARGETDB_REF => 'FINAL_DB',
               SOURCEDB_REFS => [
                  'SOURCE_DB1',
                  'SOURCE_DB2',
                  'SOURCE_DB3',
                  'SOURCE_DB4',
               ],
                    
               # ordered list of annotation layers. Genes from lower layers
               # are only retained if they do not "interfere" with genes from
               # higher layers. Genes in "Discard" layers are when assessing
               # interference, but are not written to the final database
     
               LAYERS => [
                  { 
                    ID         => 'LAYER1',
                    BIOTYPES   => ['V_segment',
                                   'J_segment', 
                                   'D_segment', 
                                   'C_segment'],
                    DISCARD    => 0,
                  },

                  { 
                    ID         => 'LAYER2',
                    BIOTYPES   => ['miRNA',
                                   'scRNA_pseudogene',
                                   'snRNA',
                                   'misc_RNA',
                                   'snoRNA_pseudogene',
                                   'rRNA',
                                   'snRNA_pseudogene',
                                   'rRNA_pseudogene',
                                   'snoRNA',
                                   'Mt_tRNA_pseudogene',
                                   'tRNA_pseudogene',
                                   'misc_RNA_pseudogene',
                                   'miRNA_pseudogene',
                                   'Mt_tRNA',
                                   'Mt_rRNA',
                                   'scRNA'
                                   ],
                    DISCARD    => 0,
                  },

                  {
                    ID       => 'LAYER3', 
                    BIOTYPES => ['protein_coding'],
                    FILTER_AGAINST => ['LAYER1'],
                    DISCARD  => 0,
                  },

                  {
                    ID       => 'LAYER4', 
                    BIOTYPES => ['pseudogene'],
                    FILTER_AGAINST => ['LAYER1', 'LAYER2', 'LAYER3'],
                    DISCARD  => 0,
                  },

               ],                            
             },

           }
           );

sub import {
  my ($callpack) = caller(0); # Name of the calling package
  my $pack = shift; # Need to move package off @_

  # Get list of variables supplied, or else everything
  my @vars = @_ ? @_ : keys( %Config );
  return unless @vars;
  
  # Predeclare global variables in calling package
  eval "package $callpack; use vars qw("
    . join(' ', map { '$'.$_ } @vars) . ")";
    die $@ if $@;


    foreach (@vars) {
	if ( defined $Config{$_} ) {
            no strict 'refs';
	    # Exporter does a similar job to the following
	    # statement, but for function names, not
	    # scalar variables:
	    *{"${callpack}::$_"} = \$Config{ $_ };
	} else {
	    die "Error: Config: $_ not known\n";
	}
    }
}

1;
