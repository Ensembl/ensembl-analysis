# Ensembl module for Bio::EnsEMBL::Analysis::Config::Funcgen::Nessie
#
# Copyright (c) 2007 Ensembl
#

=head1 NAME

  Bio::EnsEMBL::Analysis::Config::Funcgen::Nessie

=head1 SYNOPSIS

  use Bio::EnsEMBL::Analysis::Config::Funcgen::Nessie;
  
  use Bio::EnsEMBL::Analysis::Config::Funcgen::Nessie qw(CONFIG);

=head1 DESCRIPTION

This is a module needed to provide configuration for the
Nessie RunnableDBs.

NESSIE_CONFIG is an hash of hashes which contains analysis specific
settings and is keyed on logic_name

=head1 AUTHOR

This module was created by Stefan Graf. It is part of the 
Ensembl project: http://www.ensembl.org/

=head1 CONTACT

Post questions to the Ensembl development list: ensembl-dev@ebi.ac.uk

=cut

package Bio::EnsEMBL::Analysis::Config::Funcgen::Nessie;

use strict;
use vars qw(%Config);

%Config = 
    (
     CONFIG => {
         DEFAULT => {
             EFGDB => {
                 -dbname => $ENV{'DBNAME'},
                 -host => $ENV{'DBHOST'},
                 -port => $ENV{'DBPORT'} || 3306,
                 -species => $ENV{'SPECIES'},
                 -user => 'ensadmin',
                 -pass => 'ensembl',
             },
             MODULE            => 'Nessie',
             PROGRAM           => 'nessie',
             PROGRAM_FILE      => 'nessie',
             VERSION           => '0.13',
             #PARAMETERS        => undef,
             TRAIN_PARAMETERS  => " --onestep=$ENV{HOME}/bin/train_state.para",
             #PEAK_PARAMETERS   => " --bridge --gap 500 --split 2500 --mindist 400 --minpost 0.99",
             NORM_METHOD       => 'VSN_GLOG', 
             RESULT_SET_REGEXP => 'BR._TR.', 
             SCORE_FACTOR      => 1,
             ANALYSIS_WORK_DIR => "$ENV{ANALYSIS_WORK_DIR}/$ENV{DBNAME}",
         },

         #--replicates=2 --onestep="/nfs/acari/graef/bin/train_state.para"

         # NimbleGen data
         # (recommended for standard ChIP-chip fragment length ~300-600)
         'Nessie_NG' => {
             PARAMETERS => ' --distribution="weibull" --fit-method="slope"',
             PEAK_PARAMETERS   => " --bridge --gap 500 --split 2500 --mindist 400 --minpost 0.99",
         },

         # PCR array based data
         'Nessie_PCR' => {
             PARAMETERS => ' --distribution="normal" --fit-method="full"',
         },

         # Affymetrix data and NimbleGen
         # (use with very short fragments hybridised to arrays ~200bp)
         'Nessie_200' => {
             PARAMETERS => ' --distribution="normal" --fit-method="slope" ',
         },

     });

sub import {
    my ($callpack) = caller(0); # Name of the calling package
    my $pack = shift; # Need to move package off @_
    
    # Get list of variables supplied, or else all
    my @vars = @_ ? @_ : keys(%Config);
    return unless @vars;
    
    # Predeclare global variables in calling package
    eval "package $callpack; use vars qw("
        . join(' ', map { '$'.$_ } @vars) . ")";
    die $@ if $@;
    
    
    foreach (@vars) {
        if (defined $Config{ $_ }) {
            no strict 'refs';
            # Exporter does a similar job to the following
            # statement, but for function names, not
            # scalar variables:
            *{"${callpack}::$_"} = \$Config{ $_ };
        } else {
            die "Error: Config: $_ not known\n";
        }
    }
}

1;
