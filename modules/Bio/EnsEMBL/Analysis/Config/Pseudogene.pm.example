# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
# Copyright [2016-2022] EMBL-European Bioinformatics Institute
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#      http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# POD documentation - main docs before the code

=head1 NAME

Bio::EnsEMBL::Analysis::Config::Pseudogene

=head1 SYNOPSIS

    use Bio::EnsEMBL::Analysis::Config::Pseudogene_config;

=head1 DESCRIPTION

Provides configuration for:
Bio::EnsEMBL::Analysis::Runnable::Pseudogene.pm
Bio::EnsEMBL::Analysis::RunnableDB::Spliced_elsewhere 
Bio::EnsEMBL::Analysis::RunnableDB::PSILC


=head1 CONTACT

=cut


package Bio::EnsEMBL::Analysis::Config::Pseudogene;
use strict;
use vars qw( %Config );

# Hash containing config info
%Config = (	
 PSEUDOGENE_CONFIG_BY_LOGIC  => {
    DEFAULT => {
               # you can set the input- and output database - the names should point to 
               # keys in Database.pm 
               PS_INPUT_DATABASE  => 'GENEBUILD_DB',  
               PS_OUTPUT_DATABASE => 'PSEUDO_DB',     

	       # configs for the introns in repeats test  

               # introns longer than the following are considered "real"
               PS_FRAMESHIFT_INTRON_LENGTH => 9,
	       # total length of introns
	       PS_MAX_INTRON_LENGTH   => '5000',
	       # Types of repeats to run the anaysis with
	       PS_REPEAT_TYPES =>  ['LINE','LTR','SINE'],
	       # max percent coverage of the introns with the above repeats
	       PS_MAX_INTRON_COVERAGE => '80',
	       # max allowed exon coverage with the above repeats
	       PS_MAX_EXON_COVERAGE   => '99',
	       PS_NUM_FRAMESHIFT_INTRONS  => 1,
	       PS_NUM_REAL_INTRONS  => 1,
	       # biotype of genes to check
	       PS_BIOTYPE  => 'ensembl',  
               
	       # Blessed genes dont get called pseudogenes
               # Biotype is a transcript biotype
	       BLESSED_BIOTYPES => { 'ccds_gene' => 1 },	
				      
	       # configs for the spliced elsewhere tests
	       # %ID of a tbalstx of the (presumed) retrotransposed query sequence to its 
	       # homolog that is spliced elsewhere in the genome. hits falling below 
	       # this cutoff are ignored (80%) is suggested
	       PS_PERCENT_ID_CUTOFF   => 40,
	       PS_P_VALUE_CUTOFF   => '1.0e-50',
	       PS_RETOTRANSPOSED_COVERAGE   => 80,
	       PS_ALIGNED_GENOMIC  => 100,
	       # logic name to give to pseudogenes
               PS_PSEUDO_TYPE      => 'pseudogene',

               # if a gene is found to be a pseudogene, its gene biotype will be changed to
               # PS_PSEUDO_TYPE. By default, the biotype of its transcript will also be changed
               # to PS_PSEUDO_TYPE.  If you want to keep the original transcript biotype
               # instead (so you can keep track of what type of models actually got turned into a
               # pseudogene), set KEEP_TRANS_BIOTYPE to 1.

               KEEP_TRANS_BIOTYPE  => 0,

	       # logic name to give genes with exons covered by repeats 
	       # if left blank they will just get deleted (recommended)
               PS_REPEAT_TYPE      => '',

	       # analysis logic names to run over genes falling into these categories
	       SINGLE_EXON      => 'spliced_elsewhere',
	       INDETERMINATE    => '',
	       RETROTRANSPOSED  => '',
	       # if you dont wish to run further tests on retro transposed genes
	       # What type would you like to give them?
               # previously set to 'retrotransposed', we change to 'processed_pseudogene' from e70 onwards.
	       RETRO_TYPE       => 'processed_pseudogene',

	       SPLICED_ELSEWHERE_LOGIC_NAME => 'spliced_elsewhere',
	       PSILC_LOGIC_NAME => 'Psilc',

               # Ignore the following config unless also running PSILC and/or Spliced_elsewhere

	       # SPLICED ELSEWHERE SPECIFIC CONFIG
	       # ratio of the spans of the retrotransposed gene vs its spliced homologue
	       # spliced / retrotransposed
	       # ie: 1 is the same length genes 
	       # many retrotransposed genes have a ratio > 10
	       # used to make retrotransposition decision
	       PS_SPAN_RATIO          => 3,
	       # mimimum number of exons for the spliced gene to have
	       PS_MIN_EXONS           => 4,
	       # path of blast db of multi exon genes
	       PS_MULTI_EXON_DIR       => "/path/to/my/blast/directory/" ,
	       # Chunk size
	       PS_CHUNK => '50',
	       DEBUG => '1',

	       # PSILC SPECIFIC CONFIG
	       # Homolog databases
	       SUBJECT              => 'human',
	       PSILC_SUBJECT_DBNAME => 'homo_sapiens_core_28_35a',
	       PSILC_SUBJECT_DBHOST => 'ecs2',
	       PSILC_SUBJECT_DBPORT => '3365',

	       ORTH1                => 'mouse',
	       PSILC_ORTH1_DBNAME   => 'mus_musculus_core_28_33d',
	       PSILC_ORTH1_DBHOST   => 'ecs2',
	       PSILC_ORTH1_DBPORT   => '3365',

	       ORTH2                => 'rat',
	       PSILC_ORTH2_DBNAME   => 'rattus_norvegicus_core_28_3e',
	       PSILC_ORTH2_DBHOST   => 'ecs2',
	       PSILC_ORTH2_DBPORT   => '3365',

	       PSILC_WORK_DIR       => '/PSILC/output/directory',
	       # Max number of transcripts for each species
	       PS_SPECIES_LIMIT     => '5',
	       # directory and file name of 3 species blast db
	       PSILC_BLAST_DB       => '/my/multispecies/blast/dir',
	       PSILC_CHUNK          => '30',
	       # Only run PSILC over the longest transript in a gene if set to 1
	       # should speed it up if running over a very large dataset
	       REP_TRANSCRIPT       => '',
               },

               # Hashes for individual analyses must be present (even if left empty)
               # or else the code will throw

               pseudogene => {},
               spliced_elsewhere => {} , 
	
	   }
	);	

sub import {
  my ($callpack) = caller(0); # Name of the calling package
  my $pack = shift; # Need to move package off @_

  # Get list of variables supplied, or else everything
  my @vars = @_ ? @_ : keys( %Config );
  return unless @vars;
  
  # Predeclare global variables in calling package
  eval "package $callpack; use vars qw("
    . join(' ', map { '$'.$_ } @vars) . ")";
    die $@ if $@;


    foreach (@vars) {
	if ( defined $Config{$_} ) {
            no strict 'refs';
	    # Exporter does a similar job to the following
	    # statement, but for function names, not
	    # scalar variables:
	    *{"${callpack}::$_"} = \$Config{ $_ };
	} else {
	    die "Error: Config: $_ not known\n";
	}
    }
}


1;
